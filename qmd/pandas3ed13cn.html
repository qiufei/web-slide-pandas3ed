<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>python数据分析 🐍</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<link href="../https://assets.qiufei.site/personal/profile.jpg" rel="icon" type="image/jpeg">
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ea72dc5fed832574809a9c94082fbbb.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-681fbf911679f9b3dbf9743eb275ba49.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-7e49aeac8059a213a463aa1a739e8272.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="https://assets.qiufei.site/setup/styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://qiufei.github.io"> 
<span class="menu-text">首页</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://qiufei.github.io/web-slide"> 
<span class="menu-text">课件</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">简介</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">python数据分析 🐍</h1>
<p class="subtitle lead">数据分析示例</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="第-13-章---数据分析示例" class="level2">
<h2 class="anchored" data-anchor-id="第-13-章---数据分析示例">第 13 章 - 数据分析示例</h2>
<ul>
<li>我们已经到达最后一章了！🥳</li>
<li>重点：将数据分析技术应用于真实世界的数据集。</li>
<li>目标：从原始数据中提取有意义的见解。</li>
<li>演示的技术具有广泛的适用性。</li>
<li>数据集可在本书的 GitHub/Gitee 存储库中找到。</li>
</ul>
<p><img src="chapter13_introduction.png" class="img-fluid"></p>
</section>
<section id="数据挖掘机器学习和统计学习" class="level2">
<h2 class="anchored" data-anchor-id="数据挖掘机器学习和统计学习">数据挖掘、机器学习和统计学习</h2>
<ul>
<li>数据挖掘、机器学习和统计学习有一个共同的目标：从数据中提取有价值的见解并做出预测。</li>
<li>核心区别在于它们实现这一目标的<em>方式</em>。</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[数据挖掘] --&gt; C(共同点: 洞察与预测)
    B[机器学习] --&gt; C
    D[统计学习] --&gt; C
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="数据挖掘" class="level2">
<h2 class="anchored" data-anchor-id="数据挖掘">数据挖掘 ⛏️</h2>
<ul>
<li><strong>定义：</strong> 在大型数据集中发现模式、异常和关系，以预测结果。</li>
<li><strong>重点：</strong> 发现以前<em>未知</em>的模式。探索和发现！</li>
<li><strong>技术：</strong> 结合了机器学习、统计学和数据库系统的方法。</li>
<li><strong>示例：</strong> 一家超市发现购买尿布 🧷 的顾客通常也会购买啤酒 🍺。一个意想不到的关联！</li>
</ul>
<p><img src="datamining.png" class="img-fluid"></p>
</section>
<section id="机器学习" class="level2">
<h2 class="anchored" data-anchor-id="机器学习">机器学习 🤖</h2>
<ul>
<li><strong>定义</strong>：算法通过经验（数据）自动改进。侧重于预测和决策。</li>
<li><strong>重点</strong>：系统根据数据<em>学习和做出决策</em>，无需明确的规则。</li>
<li><strong>类型</strong>：
<ul>
<li><strong>监督学习</strong>：在标记数据上进行训练（例如，垃圾邮件/非垃圾邮件分类 📧）。</li>
<li><strong>无监督学习</strong>：在未标记数据中发现隐藏结构（例如，客户细分 👥）。</li>
<li><strong>强化学习</strong>：智能体通过与环境交互来做出决策（例如，机器人学习行走 🚶）。</li>
</ul></li>
<li><strong>示例</strong>：根据大小、位置和卧室等特征预测房价 🏠。算法学习这种关系。</li>
</ul>
<p><img src="machinelearning.png" class="img-fluid"></p>
</section>
<section id="统计学习" class="level2">
<h2 class="anchored" data-anchor-id="统计学习">统计学习 📊</h2>
<ul>
<li><strong>定义</strong>：用于建模和理解复杂数据集的工具。一个将统计方法应用于从数据中学习的框架。</li>
<li><strong>重点</strong>：强调<em>模型及其可解释性</em>、精确性和不确定性。连接统计学和机器学习。</li>
<li><strong>关键概念</strong>：
<ul>
<li><strong>偏差-方差权衡</strong>：平衡近似误差（偏差）和对训练数据的敏感性（方差）。</li>
<li><strong>模型选择</strong>：选择最佳模型。</li>
<li><strong>正则化</strong>：通过惩罚复杂性来防止过拟合。</li>
</ul></li>
<li><strong>示例</strong>：使用线性回归来理解广告支出 📈 和销售额之间的关系，并带有置信区间。</li>
</ul>
<p><img src="statisticallearning.png" class="img-fluid"></p>
</section>
<section id="来自-1.usa.gov-的-bitly-数据" class="level2">
<h2 class="anchored" data-anchor-id="来自-1.usa.gov-的-bitly-数据">13.1 来自 1.USA.gov 的 Bitly 数据</h2>
<ul>
<li><strong>背景：</strong>
<ul>
<li>Bitly（URL 缩短服务）和 USA.gov 于 2011 年合作。</li>
<li>来自缩短 .gov 或 .mil 链接的用户的匿名数据。</li>
<li>每小时快照（文本文件）。</li>
<li>服务已停止，但数据已保留。</li>
</ul></li>
<li><strong>数据格式：</strong>
<ul>
<li>每行都是一个 JSON（JavaScript 对象表示法）对象。</li>
<li>JSON 是人类可读的。</li>
</ul></li>
</ul>
<p><img src="bitly_data_intro.png" class="img-fluid"></p>
</section>
<section id="json-数据示例" class="level2">
<h2 class="anchored" data-anchor-id="json-数据示例">JSON 数据示例</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span> <span class="dt">"a"</span><span class="fu">:</span> <span class="st">"Mozilla</span><span class="ch">\/</span><span class="st">5.0 (Windows NT 6.1; WOW64) AppleWebKit</span><span class="ch">\/</span><span class="st">535.11 (KHTML, like Gecko) Chrome</span><span class="ch">\/</span><span class="st">17.0.963.78 Safari</span><span class="ch">\/</span><span class="st">535.11"</span><span class="fu">,</span> <span class="dt">"c"</span><span class="fu">:</span> <span class="st">"US"</span><span class="fu">,</span> <span class="dt">"nk"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span> <span class="dt">"tz"</span><span class="fu">:</span> <span class="st">"America</span><span class="ch">\/</span><span class="st">New_York"</span><span class="fu">,</span> <span class="dt">"gr"</span><span class="fu">:</span> <span class="st">"MA"</span><span class="fu">,</span> <span class="dt">"g"</span><span class="fu">:</span> <span class="st">"A6q0VH"</span><span class="fu">,</span> <span class="dt">"h"</span><span class="fu">:</span> <span class="st">"wfLQtf"</span><span class="fu">,</span> <span class="dt">"l"</span><span class="fu">:</span> <span class="st">"orofrog"</span><span class="fu">,</span> <span class="dt">"al"</span><span class="fu">:</span> <span class="st">"en-US,en;q=0.8"</span><span class="fu">,</span> <span class="dt">"hh"</span><span class="fu">:</span> <span class="st">"1.usa.gov"</span><span class="fu">,</span> <span class="dt">"r"</span><span class="fu">:</span> <span class="st">"http:</span><span class="ch">\/\/</span><span class="st">www.facebook.com</span><span class="ch">\/</span><span class="st">l</span><span class="ch">\/</span><span class="st">7AQEFzjSi</span><span class="ch">\/</span><span class="st">1.usa.gov</span><span class="ch">\/</span><span class="st">wfLQtf"</span><span class="fu">,</span> <span class="dt">"u"</span><span class="fu">:</span> <span class="st">"http:</span><span class="ch">\/\/</span><span class="st">www.ncbi.nlm.nih.gov</span><span class="ch">\/</span><span class="st">pubmed</span><span class="ch">\/</span><span class="st">22415991"</span><span class="fu">,</span> <span class="dt">"t"</span><span class="fu">:</span> <span class="dv">1331923247</span><span class="fu">,</span> <span class="dt">"hc"</span><span class="fu">:</span> <span class="dv">1331822918</span><span class="fu">,</span> <span class="dt">"cy"</span><span class="fu">:</span> <span class="st">"Danvers"</span><span class="fu">,</span> <span class="dt">"ll"</span><span class="fu">:</span> <span class="ot">[</span> <span class="fl">42.576698</span><span class="ot">,</span> <span class="fl">-70.954903</span> <span class="ot">]</span> <span class="fu">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong>结构：</strong> JSON 对象位于大括号 <code>{}</code> 中。</li>
<li><strong>键值对：</strong> 数据以键值对形式存在（例如，<code>"a": "Mozilla/..."</code>）。</li>
<li><strong>数据类型：</strong> 值可以是字符串、数字、数组（如 <code>"ll"</code>）或其他 JSON 对象。</li>
<li>**<code>{python} 和 JSON**:</code>{python} 的 <code>json</code> 库可以轻松地将 JSON 字符串转换为 ```{python} 字典。</li>
</ul>
</section>
<section id="在-python-中读取-json-数据" class="level2">
<h2 class="anchored" data-anchor-id="在-python-中读取-json-数据">在 ```{python} 中读取 JSON 数据</h2>
<p>import json # 导入 json 库</p>
<p>path = “datasets/bitly_usagov/example.txt” # 文件路径</p>
<p>with open(path) as f: # 打开文件 records = [json.loads(line) for line in f] # 列表推导式：逐行读取并解析 JSON</p>
<p>print(records[0]) # 打印第一条记录（一个字典）</p>
<pre><code>
-   **`import json`**: 导入 JSON 库。
-   **`open(path)`**: 打开文件。
-   **`json.loads(line)`**: 将 JSON 行解析为 ```{python} 字典。
-   **列表推导式**: `[... for line in f]` 创建一个字典列表。
-   **`records`**: 现在是一个 ```{python} 字典的列表。

## 访问字典中的数据

print(records[0]['tz'])  # 访问 'tz'（时区）字段</code></pre>
<ul>
<li>使用字典键访问（方括号）来获取值。</li>
<li><code>records[0]</code> 获取第一个字典。</li>
<li><code>['tz']</code> 访问键 “tz” 对应的值。</li>
</ul>
</section>
<section id="统计时区纯-python" class="level2">
<h2 class="anchored" data-anchor-id="统计时区纯-python">统计时区（纯 ```{python}）</h2>
<ul>
<li><strong>目标：</strong> 找到最常见的时区（<code>tz</code> 字段）。</li>
<li><strong>方法 1：字典和循环</strong>（基本，但效率较低）</li>
</ul>
</section>
<section id="原始幻灯片中未显示但这是一个很好的比较" class="level1">
<h1>原始幻灯片中未显示，但这是一个很好的比较</h1>
<p>def get_counts(sequence): counts = {} # 初始化一个空字典来存储计数 for x in sequence: # 遍历序列中的每个元素 if x in counts: # 如果元素已存在于字典中 counts[x] += 1 # 计数加 1 else: # 如果元素不存在于字典中 counts[x] = 1 # 将元素添加到字典，并将计数设置为 1 return counts # 返回计数结果</p>
<pre><code>
- **方法 2：`defaultdict`**（更高效且更 ```{python}ic）

``````{python}
from collections import defaultdict  # 导入 defaultdict

def get_counts2(sequence):
    counts = defaultdict(int)  # 使用 defaultdict，默认值为 0
    for x in sequence:  # 遍历序列中的每个元素
        counts[x] += 1  # 自动处理键不存在的情况，直接加 1
    return counts  #返回计数结果</code></pre>
<ul>
<li><strong><code>defaultdict(int)</code></strong>: 如果找不到键，则使用默认值 0 添加它。避免了 <code>if x in counts</code> 检查。</li>
</ul>
<section id="统计时区纯-python--处理缺失的键" class="level2">
<h2 class="anchored" data-anchor-id="统计时区纯-python--处理缺失的键">统计时区（纯 ```{python}）- 处理缺失的键</h2>
<p>``````goylqeae #原始代码 (会导致 KeyError) # time_zones = [rec[“tz”] for rec in records]</p>
<p>#使用 if 条件进行更正 time_zones = [rec[“tz”] for rec in records if “tz” in rec] # 列表推导式,如果字典中有’tz’键，则添加到列表中 print(time_zones[:10]) #打印前10个时区</p>
<pre><code>
-   **`KeyError` 解释**: 如果记录*没有* 'tz' 键，则访问 `rec["tz"]` 会引发 `KeyError`。
-   **解决方案**:  `if "tz" in rec` 在访问之前检查键是否*存在*。这可以防止错误。

## 统计时区（纯 ```{python}）- 获取 Top 计数

``````{python}
def top_counts(count_dict, n=10):
    #将字典转换为(值，键)对的列表
    value_key_pairs = [(count, tz) for tz, count in count_dict.items()]
    value_key_pairs.sort() #对列表进行排序
    return value_key_pairs[-n:]  # 返回最后 n 个元素（即最大的 n 个）

# 使用 Counter 类（最高效且最 ```{python}ic）
from collections import Counter  # 导入 Counter 类
counts = Counter(time_zones)  # 使用 Counter 统计时区
print(counts.most_common(10))  # 直接获取出现次数最多的前 10 个时区</code></pre>
<ul>
<li><strong><code>top_counts</code> 函数:</strong> 获取出现次数最多的 <em>n</em> 个项目（自定义函数）。</li>
<li><strong><code>Counter</code> 类:</strong> 统计项目出现次数的<em>最佳</em>方式。<code>most_common(10)</code> 直接返回前 10 个。</li>
</ul>
</section>
<section id="统计时区-pandas" class="level2">
<h2 class="anchored" data-anchor-id="统计时区-pandas">统计时区 (pandas) 🐼</h2>
<ul>
<li><strong>pandas DataFrame:</strong> 一种更强大、更方便的处理表格数据的方式。</li>
</ul>
<p>``````goylqeae import pandas as pd # 导入 pandas</p>
<p>frame = pd.DataFrame(records) # 从字典列表创建 DataFrame print(frame.info()) # 显示 DataFrame 的摘要信息</p>
<pre><code>
-   **`pd.DataFrame(records)`**:  将字典列表转换为 DataFrame。pandas 会自动推断列名和类型。
-   **`frame.info()`**:  提供：
    -   行数和列数。
    -   列名和数据类型。
    -   非空值计数（显示缺失数据）。
    -   内存使用情况。

## `frame.info()` 输出解释
</code></pre>
<p>&lt;class ‘pandas.core.frame.DataFrame’&gt; RangeIndex: 3560 entries, 0 to 3559 Data columns (total 18 columns): # Column Non-Null Count Dtype — —— ————– —– 0 a 3440 non-null object 1 c 2919 non-null object … 16 <em>heartbeat</em> 120 non-null float64 17 kw 93 non-null object dtypes: float64(4), object(14) memory usage: 500.8+ KB</p>
<pre><code>
-   **`RangeIndex`**:  总行数 (3560) 和索引范围 (0 to 3559)。
-   **`Data columns`**:  每列、非空计数和数据类型。
    -   `object`: 通常是文本（字符串）。
    -   `float64`: 浮点数。
    -   `int64`: 整数。
-   **`Non-Null Count`**:  突出显示缺失值（例如，`c` 有 641 个缺失值）。
- `dtypes` and `memory usage`: 汇总信息.

## 使用 pandas 处理时区

``````{python}
print(frame['tz'].head())  # 显示前几个时区

tz_counts = frame['tz'].value_counts()  # 统计每个时区出现的次数
print(tz_counts.head())  # 显示出现次数最多的前几个时区</code></pre>
<ul>
<li><strong><code>frame['tz']</code></strong>: 选择 ‘tz’ 列（一个 pandas Series）。</li>
<li><strong><code>.head()</code></strong>: 显示前 5 行。</li>
<li><strong><code>.value_counts()</code></strong>: 统计每个唯一值出现的次数。比纯 ```{python} <em>简单得多</em>！</li>
</ul>
</section>
<section id="在-pandas-中处理缺失数据" class="level2">
<h2 class="anchored" data-anchor-id="在-pandas-中处理缺失数据">在 pandas 中处理缺失数据</h2>
<p>```<code>goylqeae clean_tz = frame['tz'].fillna('Missing')  # 将 NaN 替换为 "Missing" clean_tz[clean_tz == ''] = 'Unknown'      # 将空字符串替换为 "Unknown" tz_counts = clean_tz.value_counts()  # 重新统计时区 print(tz_counts.head())  # 显示处理后的结果</code></p>
<ul>
<li><strong><code>.fillna('Missing')</code></strong>: 将缺失值（pandas 中的 <code>NaN</code>）替换为 “Missing”。</li>
<li><strong><code>clean_tz[clean_tz == ''] = 'Unknown'</code></strong>: 将空字符串替换为 “Unknown”（布尔索引）。</li>
</ul>
</section>
<section id="使用-seaborn-进行可视化" class="level2">
<h2 class="anchored" data-anchor-id="使用-seaborn-进行可视化">使用 seaborn 进行可视化 📊</h2>
<p>``````goylqeae import seaborn as sns # 导入 seaborn import matplotlib.pyplot as plt #导入matplotlib</p>
<p>subset = tz_counts.head() # 获取出现次数最多的前几个时区 sns.barplot(y=subset.index, x=subset.to_numpy()) # 创建水平条形图 plt.show() # 显示图形</p>
<pre><code>
-   **`import seaborn as sns`**: 导入 seaborn（基于 matplotlib 构建）。
-   **`subset = tz_counts.head()`**: 使用前几个时区以获得更清晰的可视化效果.
-   **`sns.barplot(...)`**:  创建水平条形图。
    -   `y=subset.index`: y 轴上是时区名称。
    -   `x=subset.to_numpy()`: x 轴上是计数。将 Series 转换为 numpy 数组。
- **`plt.show()`**: 显示绘图。

!['1.usa.gov 样本数据中出现次数最多的时区'](time_zone_barplot.png)

## 分析浏览器/代理信息 🌐

``````{python}
print(frame['a'][1])  # 打印第 2 条记录的 'a' 字段
print(frame['a'][50])  # 打印第 51 条记录的 'a' 字段
print(frame['a'][51][:50])  # 打印第 52 条记录的 'a' 字段的前 50 个字符

results = pd.Series([x.split()[0] for x in frame['a'].dropna()])  # 获取主要浏览器信息
print(results.head())  # 显示前几条结果
print(results.value_counts().head(8))  # 统计并显示出现次数最多的前 8 个浏览器</code></pre>
<ul>
<li><code>a</code> 字段包含浏览器/设备/应用程序信息。</li>
<li><strong><code>frame['a'][1]</code> ,etc.</strong>: 访问特定的代理字符串。</li>
<li><strong><code>.dropna()</code></strong>: 在拆分之前删除缺少 ‘a’ 值的行。</li>
<li><strong><code>x.split()[0]</code></strong>: 按空格拆分，取<em>第一个</em>元素（主要浏览器 ID）。</li>
<li><strong><code>pd.Series(...)</code></strong>: 从拆分后的字符串创建一个 Series。</li>
<li><strong><code>results.value_counts().head(8)</code></strong>: 统计并显示前 8 个。</li>
</ul>
</section>
<section id="windows-与非-windows-用户" class="level2">
<h2 class="anchored" data-anchor-id="windows-与非-windows-用户">Windows 与非 Windows 用户 💻</h2>
<p>``````goylqeae import numpy as np # 导入 numpy</p>
<p>cframe = frame[frame[‘a’].notna()].copy() # 创建一个副本，并排除’a’列为空的行 cframe[‘os’] = np.where(cframe[‘a’].str.contains(‘Windows’), # 创建新列 ‘os’ ‘Windows’, ‘Not Windows’) # 如果 ‘a’ 包含 ‘Windows’，则为 ‘Windows’，否则为 ‘Not Windows’ print(cframe[‘os’].head()) # 显示前几行 ‘os’ 列</p>
<pre><code>
-   **目标：** 分别分析 Windows/非 Windows 用户的时区。
-   **`cframe = frame[frame['a'].notna()].copy()`**:  创建一个*副本*，过滤掉缺失的 'a' 值。`.copy()` 可避免警告。
-   **`cframe['a'].str.contains('Windows')`**:  检查代理字符串是否包含 "Windows"。
-   **`np.where(...)`**: 创建一个新的 'os' 列：如果字符串包含 "Windows"，则为 "Windows"，否则为 "Not Windows"。

## 按时区和操作系统分组

``````{python}
by_tz_os = cframe.groupby(['tz', 'os'])  # 按时区和操作系统分组
agg_counts = by_tz_os.size().unstack().fillna(0)  # 分组计数，重塑，并填充缺失值为 0
print(agg_counts.head())  # 显示分组计数结果</code></pre>
<ul>
<li><strong><code>cframe.groupby(['tz', 'os'])</code></strong>: 按时区<em>和</em>操作系统分组。</li>
<li><strong><code>.size()</code></strong>: 计算每个组中的记录数（类似于 <code>value_counts()</code>，但用于分组）。</li>
<li><strong><code>.unstack()</code></strong>: 重塑。将 ‘os’ 透视为列（更易于比较）。</li>
<li><strong><code>.fillna(0)</code></strong>: 将缺失值（只有一种操作系统的时区）替换为 0。</li>
</ul>
</section>
<section id="找到最受欢迎的时区" class="level2">
<h2 class="anchored" data-anchor-id="找到最受欢迎的时区">找到最受欢迎的时区</h2>
<p>``````goylqeae # 方法 1: 使用 argsort indexer = agg_counts.sum(axis=“columns”).argsort() # 获取按总数排序的索引 print(indexer.values[:10]) # 显示排序后的前 10 个索引 count_subset = agg_counts.take(indexer[-10:]) # 获取计数最多的最后 10 行 print(count_subset) #打印</p>
</section>
</section>
<section id="方法-2-使用-nlargest-更方便" class="level1">
<h1>方法 2: 使用 nlargest (更方便)</h1>
<p>print(agg_counts.sum(axis=“columns”).nlargest(10)) # 直接获取总数最大的前 10 行</p>
<pre><code>
-   **目标**：找到总数*最多*的时区。

-   **`agg_counts.sum(axis="columns")`**: 计算每个时区的总计数。

-   **`argsort()`**:  返回将对数组进行排序的*索引*（从最少到最频繁）。

-   **`.take(indexer[-10:])`**:  选择前 10 个时区的行。

-   **`nlargest(10)`**:  获取前 10 名的*更直接*的方式。

## 可视化 Windows 和非 Windows 用户（分组条形图）

``````{python}
# 准备数据
count_subset = count_subset.stack()  # 将 'os' 列堆叠回索引
count_subset.name = 'total'  # 将 Series 命名为 'total'
count_subset = count_subset.reset_index()  # 将索引重置为普通列
print(count_subset.head())  # 显示准备好的数据
sns.barplot(x='total', y='tz', hue='os', data=count_subset)  # 创建分组条形图
plt.show()  #显示绘图</code></pre>
<ul>
<li><strong><code>count_subset.stack()</code></strong>: 将 ‘os’ 重新透视回索引（与 <code>unstack()</code> 相反）。通常用于 seaborn。</li>
<li><strong><code>count_subset.name = 'total'</code></strong>: 将 Series 值命名为 “total”。</li>
<li><strong><code>count_subset.reset_index()</code></strong>: 将索引转换为常规列（用于 seaborn）。</li>
<li><strong><code>sns.barplot(...)</code></strong>: 分组条形图。
<ul>
<li><code>x='total'</code>: x 轴上是计数。</li>
<li><code>y='tz'</code>: y 轴上是时区。</li>
<li><code>hue='os'</code>: 为 Windows/非 Windows 用户分别绘制条形。</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="windows_vs_notwindows.png" class="img-fluid figure-img"></p>
<figcaption>‘按 Windows 和非 Windows 用户划分的热门时区’</figcaption>
</figure>
</div>
<section id="标准化计数比例" class="level2">
<h2 class="anchored" data-anchor-id="标准化计数比例">标准化计数（比例）</h2>
<p>``````goylqeae def norm_total(group): group[‘normed_total’] = group[‘total’] / group[‘total’].sum() # 计算每个分组内的比例 return group</p>
<p>results = count_subset.groupby(‘tz’).apply(norm_total) # 按时区应用函数 sns.barplot(x=‘normed_total’, y=‘tz’, hue=‘os’, data=results) # 使用比例创建条形图 plt.show() #显示绘图</p>
<pre><code>
-   **目标：** 比较每个时区内 Windows/非 Windows 用户的*比例*。
-   **`norm_total(group)` 函数：**
    -   计算 `normed_total`：每个操作系统的计数除以该时区的*总*计数（比例）。
    -   返回修改后的分组。
-   **`count_subset.groupby('tz').apply(norm_total)`**:  将函数应用于每个时区分组。
-   **`sns.barplot(...)`**: 使用 'normed_total'（比例）的条形图 - 更容易比较。

!['热门时区中 Windows 和非 Windows 用户的百分比'](normalized_plot.png)

## 13.2 MovieLens 1M 数据集 🎬

-   **数据集：** MovieLens 1M (GroupLens Research)。
-   **内容：**
    -   100 万条评分。
    -   约 6,000 名用户。
    -   约 4,000 部电影。
-   **数据格式：** 三个表格：
    -   `users`: 人口统计信息（年龄、性别、职业、邮政编码）。
    -   `ratings`: 用户 ID、电影 ID、评分、时间戳。
    -   `movies`: 电影名称、类型。
-   **目标：** 探索评分、人口统计信息和类型之间的关系。

![](movielens_data_intro.png)

## 加载 MovieLens 数据

``````{python}
import pandas as pd

# 定义列名
unames = ['user_id', 'gender', 'age', 'occupation', 'zip']
# 读取 users.dat 文件
users = pd.read_table('datasets/movielens/users.dat', sep='::',
                      header=None, names=unames, engine='```{python}')

# 定义列名
rnames = ['user_id', 'movie_id', 'rating', 'timestamp']
# 读取 ratings.dat 文件
ratings = pd.read_table('datasets/movielens/ratings.dat', sep='::',
                        header=None, names=rnames, engine='```{python}')

# 定义列名
mnames = ['movie_id', 'title', 'genres']
# 读取 movies.dat 文件
movies = pd.read_table('datasets/movielens/movies.dat', sep='::',
                       header=None, names=mnames, engine='```{python}')</code></pre>
<ul>
<li><strong><code>pd.read_table</code> 的关键参数：</strong>
<ul>
<li><code>sep='::'</code>: 分隔符是两个冒号。</li>
<li><code>header=None</code>: 没有标题行。</li>
<li><code>names=unames</code> (etc.): 提供列名。</li>
<li><code>engine='```{python}'</code>: 使用 ```{python} 引擎（支持多字符分隔符）。</li>
</ul></li>
</ul>
</section>
<section id="合并-movielens-数据" class="level2">
<h2 class="anchored" data-anchor-id="合并-movielens-数据">合并 MovieLens 数据</h2>
<p>```<code>goylqeae data = pd.merge(pd.merge(ratings, users), movies)  # 合并三个 DataFrame print(data.head())  # 显示合并后的数据的前几行 print(data.iloc[0])  # 访问第一行数据</code></p>
<ul>
<li><strong><code>pd.merge()</code></strong>: 基于公共列合并 DataFrame。pandas 会自动找到它们。</li>
<li><strong>两次合并：</strong>
<ol type="1">
<li><code>pd.merge(ratings, users)</code>: 基于 <code>user_id</code> 合并。</li>
<li><code>pd.merge(..., movies)</code>: 将结果与 <code>movies</code> 基于 <code>movie_id</code> 合并。</li>
</ol></li>
<li><strong><code>data</code></strong>: 将所有信息包含在一个 DataFrame 中。</li>
</ul>
</section>
<section id="按性别分析评分" class="level2">
<h2 class="anchored" data-anchor-id="按性别分析评分">按性别分析评分</h2>
<p>```<code>goylqeae mean_ratings = data.pivot_table('rating', index='title',  # 以 'title' 为索引                                 columns='gender', aggfunc='mean')  # 以 'gender' 为列，计算平均 'rating' print(mean_ratings.head())  # 显示结果</code></p>
<ul>
<li><strong><code>data.pivot_table(...)</code></strong>: 重塑和聚合。
<ul>
<li><code>'rating'</code>: 要聚合的值（平均评分）。</li>
<li><code>index='title'</code>: 电影名称是行索引。</li>
<li><code>columns='gender'</code>: 性别 (‘M’, ‘F’) 成为列。</li>
<li><code>aggfunc='mean'</code> (默认): 计算平均值。</li>
</ul></li>
</ul>
</section>
<section id="按评分数量过滤" class="level2">
<h2 class="anchored" data-anchor-id="按评分数量过滤">按评分数量过滤</h2>
<p>``````goylqeae ratings_by_title = data.groupby(‘title’).size() # 统计每部电影的评分数量 print(ratings_by_title.head()) # 显示前几行 active_titles = ratings_by_title.index[ratings_by_title &gt;= 250] # 筛选出评分数量大于等于 250 的电影 print(active_titles) # 显示筛选结果</p>
<p>mean_ratings = mean_ratings.loc[active_titles] # 根据筛选结果过滤 mean_ratings print(mean_ratings) # 显示过滤后的 mean_ratings</p>
<pre><code>
-   **目标**：关注评分足够的电影。
-   **`data.groupby('title').size()`**:  统计每部电影的评分数。
-   **`active_titles = ...`**:  至少有 250 条评分的电影名称。
-   **`mean_ratings.loc[active_titles]`**:  过滤 `mean_ratings` 以仅包含这些电影。

## 排序和查找热门电影

``````{python}
top_female_ratings = mean_ratings.sort_values("F", ascending=False)  # 按女性评分降序排列
print(top_female_ratings.head())  # 显示女性评分最高的几部电影</code></pre>
<ul>
<li><strong><code>mean_ratings.sort_values("F", ascending=False)</code></strong>: 按 ‘F’（女性）列排序，降序（最高评分优先）。</li>
</ul>
</section>
<section id="衡量评分差异" class="level2">
<h2 class="anchored" data-anchor-id="衡量评分差异">衡量评分差异</h2>
<p>``````goylqeae mean_ratings[‘diff’] = mean_ratings[‘M’] - mean_ratings[‘F’] # 计算男性和女性评分的差异 sorted_by_diff = mean_ratings.sort_values(‘diff’) # 按差异排序 print(sorted_by_diff.head()) # 显示女性评分较高的电影（差异为负） print(sorted_by_diff[::-1].head()) # 显示男性评分较高的电影（差异为正）</p>
</section>
</section>
<section id="标准差另一种衡量差异的方法" class="level1">
<h1>标准差（另一种衡量差异的方法）</h1>
<p>rating_std_by_title = data.groupby(‘title’)[‘rating’].std() # 计算每部电影评分的标准差 rating_std_by_title = rating_std_by_title.loc[active_titles] # 过滤 print(rating_std_by_title.sort_values(ascending=False)[:10]) # 显示标准差最高的 10 部电影</p>
<pre><code>
-   **`mean_ratings['diff'] = ...`**:  新列：男性和女性平均评分之间的差异。
-   **`sorted_by_diff = ...`**: 按 'diff' 排序。
    -   `.head()`: 女性评分较高。
    -   `[::-1].head()`: 男性评分较高（反转顺序）。
-   标准差显示了分歧。

## 处理电影类型（正确的方法！）

``````{python}
# 原始: "Animation|Children's|Comedy"
movies['genre'] = movies.pop('genres').str.split('|')  # 将 'genres' 列拆分为列表，并赋值给新的'genre'列
print(movies.head())  # 显示结果
movies_exploded = movies.explode('genre')  # 展开 'genre' 列，每个类型占一行
print(movies_exploded[:10])  # 显示展开后的结果</code></pre>
<ul>
<li><strong>问题</strong>：类型是管道分隔的字符串。难以分析。</li>
<li><strong><code>movies['genres'].str.split('|')</code></strong>: 拆分为类型的<em>列表</em>。</li>
<li><strong><code>.pop('genres')</code></strong>: 删除并返回原始列。</li>
<li><strong><code>movies.explode('genre')</code></strong>: <em>每个</em>电影-类型组合都有自己的行。对于类型分析至关重要！</li>
</ul>
<section id="合并所有数据并按类型分组" class="level2">
<h2 class="anchored" data-anchor-id="合并所有数据并按类型分组">合并所有数据并按类型分组</h2>
<p>``````goylqeae ratings_with_genre = pd.merge(pd.merge(movies_exploded, ratings), users) # 合并所有数据 print(ratings_with_genre.iloc[0]) # 显示合并后第一行</p>
<p>genre_ratings = (ratings_with_genre.groupby([‘genre’, ‘age’]) # 按 ‘genre’ 和 ‘age’ 分组 [‘rating’].mean() # 计算平均 ‘rating’ .unstack(‘age’)) # 将 ‘age’ 透视为列 print(genre_ratings[:10]) # 显示结果</p>
<pre><code>
-   **`ratings_with_genre = ...`**: 合并 `movies_exploded`、`ratings` 和 `users`。每一行：评分 + 用户信息 + *单个*类型。
-   **`ratings_with_genre.iloc[0]`**: 显示第一行。
-   **`genre_ratings = ...`**: 每个类型/年龄组的平均评分。
    -   `groupby(['genre', 'age'])`: 按类型和年龄分组。
    -   `['rating'].mean()`: 平均评分。
    -   `.unstack('age')`: 年龄变成列。

## 13.3 1880-2010 年美国婴儿姓名 👶

-   **数据集：** 美国社会保障管理局 (SSA) 婴儿姓名。
-   **时间段：** 1880-2010。
-   **数据格式：** 每年一个文件：
    -   姓名
    -   性别
    -   出生人数
-   **示例 (yob1880.txt):**
    ```
    Mary,F,7065
    Anna,F,2604
    ...
    ```
-   **潜在分析：**
    -   姓名流行趋势。
    -   相对排名。
    -   命名多样性。
    -   字母/元音/辅音分析。

![](usbabynames_intro.png)

## 加载和组合婴儿姓名数据

``````{python}
import pandas as pd

# 加载单年数据（用于演示）
names1880 = pd.read_csv('datasets/babynames/yob1880.txt',
                        names=['name', 'sex', 'births'])  # 指定列名
print(names1880)  # 显示 1880 年的数据
print(names1880.groupby('sex')['births'].sum())  # 按性别统计 1880 年的总出生人数

# 加载所有年份的数据并合并
years = range(1880, 2011)  # 年份范围
pieces = []  # 用于存储每个年份的数据
for year in years:  # 遍历年份
    path = f'datasets/babynames/yob{year}.txt'  # 构建文件路径
    frame = pd.read_csv(path, names=['name', 'sex', 'births'])  # 读取数据
    frame['year'] = year  # 添加 'year' 列
    pieces.append(frame)  # 将当前年份的数据添加到列表

names = pd.concat(pieces, ignore_index=True)  # 合并所有年份的数据
print(names)  # 显示合并后的数据</code></pre>
<ul>
<li><strong><code>names1880 = pd.read_csv(...)</code></strong>: 加载一年。<code>names</code> 指定列。</li>
<li><strong><code>names1880.groupby('sex')['births'].sum()</code></strong>: 1880 年每个性别的总出生人数。</li>
<li><strong>循环遍历年份：</strong>
<ul>
<li><code>range(1880, 2011)</code>: 迭代。</li>
<li><code>f'datasets/babynames/yob{year}.txt'</code>: 文件路径（f-string）。</li>
<li><code>frame['year'] = year</code>: 添加 ‘year’ 列。</li>
<li><code>pieces.append(frame)</code>: 添加到列表。</li>
</ul></li>
<li><strong><code>names = pd.concat(pieces, ignore_index=True)</code></strong>: 合并所有 DataFrame。<code>ignore_index=True</code> 避免重复索引。</li>
</ul>
</section>
<section id="按年份和性别聚合" class="level2">
<h2 class="anchored" data-anchor-id="按年份和性别聚合">按年份和性别聚合</h2>
<p>```<code>goylqeae total_births = names.pivot_table('births', index='year',  # 以 'year' 为索引                                  columns='sex', aggfunc=sum)  # 以 'sex' 为列，计算 'births' 的总和 print(total_births.tail())  # 显示最后几行 total_births.plot(title='Total births by sex and year')  # 绘制按性别和年份划分的总出生人数 plt.show() #显示绘图</code></p>
<ul>
<li><strong><code>names.pivot_table(...)</code></strong>: 每年/每性别的总出生人数。
<ul>
<li><code>'births'</code>: 要聚合的值。</li>
<li><code>index='year'</code>: 年份是行索引。</li>
<li><code>columns='sex'</code>: 性别成为列。</li>
<li><code>aggfunc=sum</code>: 出生人数总和。</li>
</ul></li>
<li><strong><code>total_births.tail()</code></strong>: 最后几行。</li>
<li><strong><code>total_births.plot(...)</code></strong>: 趋势折线图。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="birth_by_sex_year.png" class="img-fluid figure-img"></p>
<figcaption>‘按性别和年份划分的总出生人数’</figcaption>
</figure>
</div>
</section>
<section id="计算每个名字的比例" class="level2">
<h2 class="anchored" data-anchor-id="计算每个名字的比例">计算每个名字的比例</h2>
<p>``````goylqeae def add_prop(group): group[‘prop’] = group[‘births’] / group[‘births’].sum() # 计算每个分组内的比例 return group</p>
<p>names = names.groupby([‘year’, ‘sex’]).apply(add_prop) # 按年份和性别分组，并应用函数 print(names) # 显示添加了 ‘prop’ 列的数据</p>
<pre><code>
-   **目标：** 每个名字在*每个年份和性别*中占婴儿的比例。根据总出生人数进行标准化。
-   **`add_prop(group)` 函数：**
    -   接收一个分组（年份/性别）。
    -   `group['births'] / group['births'].sum()`: 比例（出生人数除以该年份/性别的总数）。
    -   返回修改后的分组。
-   **`names.groupby(['year', 'sex']).apply(add_prop)`**:  应用于每个分组。添加 'prop' 列。

## 验证比例（健全性检查！）

``````{python}
print(names.groupby(['year', 'sex'])['prop'].sum())  # 验证每个年份和性别分组的 'prop' 总和是否为 1</code></pre>
<ul>
<li><strong>重要</strong>：始终检查您的计算！</li>
<li>按年份/性别分组，对 ‘prop’ 求和。对于每个分组，结果应为 1.0（比例加起来为 100%）。</li>
</ul>
</section>
<section id="提取前-1000-个名字" class="level2">
<h2 class="anchored" data-anchor-id="提取前-1000-个名字">提取前 1000 个名字</h2>
<p>``````goylqeae def get_top1000(group): return group.sort_values(‘births’, ascending=False)[:1000] # 按 ‘births’ 降序排列，并取前 1000 行</p>
<p>grouped = names.groupby([‘year’, ‘sex’]) # 按年份和性别分组 top1000 = grouped.apply(get_top1000) # 应用函数 top1000 = top1000.reset_index(drop=True) # 删除多级索引 print(top1000) # 显示前 1000 个名字的数据</p>
<pre><code>
-   **目标：** 每个年份/性别的前 1000 个名字（用于进一步分析）。
-   **`get_top1000(group)` 函数：**
    -   接收一个分组（年份/性别）。
    -   `group.sort_values('births', ascending=False)`: 按出生人数排序（降序）。
    -   `[:1000]`: 前 1000 行。
-   **`names.groupby(['year', 'sex']).apply(get_top1000)`**: 应用于每个分组。
-   **`top1000.reset_index(drop=True)`:** 删除多级索引.

## 分析命名趋势

``````{python}
boys = top1000[top1000['sex'] == 'M']  # 筛选出男孩的数据
girls = top1000[top1000['sex'] == 'F']  # 筛选出女孩的数据

total_births = top1000.pivot_table('births', index='year',  # 以 'year' 为索引
                                    columns='name', aggfunc=sum)  # 以 'name' 为列，计算 'births' 的总和
print(total_births.info())  # 显示信息

subset = total_births[['John', 'Harry', 'Mary', 'Marilyn']]  # 选取几个名字
subset.plot(subplots=True, figsize=(12, 10),  # 绘制子图
            title="Number of births per year")  # 设置标题
plt.show()  #显示绘图</code></pre>
<ul>
<li><strong><code>boys = ...</code></strong> 和 <strong><code>girls = ...</code></strong>: 男孩/女孩的单独 DataFrame。</li>
<li><strong><code>total_births = top1000.pivot_table(...)</code></strong>: 特定名字的趋势。
<ul>
<li><code>'births'</code>: 要聚合的值。</li>
<li><code>index='year'</code>: 年份是行索引。</li>
<li><code>columns='name'</code>: 每个名字是一列。</li>
<li><code>aggfunc=sum</code>: 求和。</li>
</ul></li>
<li><strong><code>subset.plot(...)</code></strong>: 绘制趋势图。
<ul>
<li><code>subplots=True</code>: 每个名字一个单独的图。</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="boyandgirlnames.png" class="img-fluid figure-img"></p>
<figcaption>‘几个男孩和女孩名字随时间的变化’</figcaption>
</figure>
</div>
</section>
<section id="衡量命名多样性的增加" class="level2">
<h2 class="anchored" data-anchor-id="衡量命名多样性的增加">衡量命名多样性的增加</h2>
<p>``````goylqeae table = top1000.pivot_table(‘prop’, index=‘year’, # 以 ‘year’ 为索引 columns=‘sex’, aggfunc=sum) # 以 ‘sex’ 为列，计算 ‘prop’ 的总和 table.plot(title=‘Sum of table1000.prop by year and sex’, # 绘制按年份和性别划分的 ‘prop’ 总和 yticks=np.linspace(0, 1.2, 13)) # 设置 y 轴刻度 plt.show() #显示绘图</p>
<p>df = boys[boys[‘year’] == 2010] # 筛选出 2010 年的男孩数据 prop_cumsum = df[‘prop’].sort_values(ascending=False).cumsum() # 计算 2010 年男孩名字 ‘prop’ 的累积和 print(prop_cumsum[:10]) # 显示前 10 个累积和 print(prop_cumsum.searchsorted(0.5)) # 找到累积和达到 0.5 的索引, 结果为116, 加上1, 结果为117.</p>
<p>df = boys[boys.year == 1900] # 筛选出 1900 年的男孩数据 in1900 = df.sort_values(‘prop’, ascending=False).prop.cumsum() # 计算 1900 年男孩名字 ‘prop’ 的累积和 print(in1900.searchsorted(0.5) + 1) # 找到累积和达到 0.5 的索引+1, 结果为25</p>
<pre><code>
-   **目标：** 命名是否变得更加多样化？（父母是否从更多名字中选择？）
-   **`table = top1000.pivot_table(...)`**: 每个年份/性别的 'prop' *总和*。比例下降 = 多样性增加。
-   **`prop_cumsum = ... .cumsum()`**: 2010 年男孩 'prop' 的*累积和*（已排序）。找出多少个名字达到 50% 的出生人数。
-   **`prop_cumsum.searchsorted(0.5)`**:  累积和达到 0.5 (50%) 的索引。因为数组的下标是从0开始的，所以结果需要加1.
-   对 1900 年执行类似步骤。

!['按性别划分，前 1000 个名字所代表的出生比例'](prop_top1000.png)

## 衡量命名多样性的增加（续）- 泛化

``````{python}
def get_quantile_count(group, q=0.5):
    group = group.sort_values('prop', ascending=False)  # 按 'prop' 降序排列
    return group.prop.cumsum().searchsorted(q) + 1  # 计算累积和，找到达到分位数 q 的索引+1

diversity = top1000.groupby(['year', 'sex']).apply(get_quantile_count)  # 按年份和性别分组，并应用函数
diversity = diversity.unstack()  # 将结果重塑

fig = plt.figure()  # 创建图形
diversity.plot(title="Number of popular names in top 50%")  # 绘制多样性指标
plt.show()  #显示绘图</code></pre>
<ul>
<li><strong><code>get_quantile_count(group, q=0.5)</code> 函数：</strong>
<ul>
<li>接收一个分组（年份/性别）和分位数（默认为 0.5）。</li>
<li>按 ‘prop’ 排序（降序）。</li>
<li>‘prop’ 的累积和。</li>
<li><code>searchsorted(q)</code>: 总和达到分位数的索引。加 1。</li>
</ul></li>
<li><strong><code>top1000.groupby(['year', 'sex']).apply(get_quantile_count)</code></strong>: 应用于每个分组。</li>
<li><strong><code>diversity.unstack()</code></strong>: 重塑以进行绘图。</li>
<li>图表显示了达到 50% 出生人数所需的姓名数量，随时间变化，按性别划分。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="diversity.png" class="img-fluid figure-img"></p>
<figcaption>‘按年份划分的多样性指标图’</figcaption>
</figure>
</div>
</section>
<section id="最后一个字母革命" class="level2">
<h2 class="anchored" data-anchor-id="最后一个字母革命">“最后一个字母”革命 🔤</h2>
<p>``````goylqeae def get_last_letter(x): return x[-1] # 获取字符串的最后一个字母</p>
<p>last_letters = names[‘name’].map(get_last_letter) # 将函数应用于 ‘name’ 列，获取最后一个字母 last_letters.name = ‘last_letter’ # 将 Series 命名为 ‘last_letter’</p>
<p>table = names.pivot_table(‘births’, index=last_letters, # 以 ‘last_letter’ 为索引 columns=[‘sex’, ‘year’], aggfunc=sum) # 以 ‘sex’ 和 ‘year’ 为列，计算 ‘births’ 的总和 subtable = table.reindex(columns=[1910, 1960, 2010], level=‘year’) # 选取特定年份 print(subtable.head()) # 显示前几行 print(subtable.sum()) # 计算每个年份和性别的总和</p>
<p>letter_prop = subtable / subtable.sum() # 计算每个年份和性别中，每个字母的比例 print(letter_prop.head()) # 显示前几行</p>
<pre><code>
-   **想法：** 分析最后一个字母随时间的分布。
-   **`get_last_letter(x)` 函数：**  返回最后一个字符。
-   **`names['name'].map(get_last_letter)`**: 应用于 'name'，创建 `last_letters` Series。
-   **`table = names.pivot_table(...)`**: 按最后一个字母、性别和年份统计出生人数。
-   **`subtable = ...`**: 选择特定年份 (1910, 1960, 2010)。
-   **`letter_prop = subtable / subtable.sum()`**:  每个字母结尾的名字的*比例*（标准化）。

``````{python}
import matplotlib.pyplot as plt

fig, axes = plt.subplots(2, 1, figsize=(10, 8))  # 创建 2x1 的子图
letter_prop['M'].plot(kind='bar', rot=0, ax=axes[0], title='Male')  # 绘制男性最后一个字母的条形图
letter_prop['F'].plot(kind='bar', rot=0, ax=axes[1], title='Female',  # 绘制女性最后一个字母的条形图
                      legend=False)  # 不显示图例
plt.show()  #显示绘图</code></pre>
<ul>
<li><strong><code>plt.subplots(2, 1, ...)</code></strong>: 两个子图（男性/女性）。</li>
<li><strong><code>letter_prop['M'].plot(...)</code></strong> 和 <strong><code>letter_prop['F'].plot(...)</code></strong>: 最后一个字母分布的条形图。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="letter_prop.png" class="img-fluid figure-img"></p>
<figcaption>‘男孩和女孩名字以每个字母结尾的比例’</figcaption>
</figure>
</div>
</section>
<section id="最后一个字母革命续--关注特定字母" class="level2">
<h2 class="anchored" data-anchor-id="最后一个字母革命续--关注特定字母">“最后一个字母”革命（续）- 关注特定字母</h2>
<p>```<code>goylqeae letter_prop = table / table.sum()  # 计算所有年份的比例 dny_ts = letter_prop.loc[['d', 'n', 'y'], 'M'].T  # 选取男性名字中以 'd', 'n', 'y' 结尾的比例，并转置 print(dny_ts.head())  # 显示前几行 dny_ts.plot()  # 绘制趋势图 plt.show()  #显示绘图</code></p>
<ul>
<li><strong><code>letter_prop = table / table.sum()</code></strong>: 比例（所有年份）。</li>
<li><strong><code>dny_ts = letter_prop.loc[['d', 'n', 'y'], 'M'].T</code></strong>: 选择男性的 ‘d’、‘n’、‘y’，转置 (.T) 以获得时间序列。</li>
<li><strong><code>dny_ts.plot()</code></strong>: 绘制这些字母的趋势。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="boy_dny.png" class="img-fluid figure-img"></p>
<figcaption>‘随着时间的推移，以 d/n/y 结尾的男孩名字的比例’</figcaption>
</figure>
</div>
</section>
<section id="变成女孩名字的男孩名字反之亦然" class="level2">
<h2 class="anchored" data-anchor-id="变成女孩名字的男孩名字反之亦然">变成女孩名字的男孩名字（反之亦然）🔄</h2>
<p>``````goylqeae all_names = pd.Series(top1000[‘name’].unique()) # 获取所有唯一的名字 lesley_like = all_names[all_names.str.contains(‘Lesl’)] # 筛选出包含 ‘Lesl’ 的名字 print(lesley_like) # 显示筛选结果</p>
<p>filtered = top1000[top1000[‘name’].isin(lesley_like)] # 筛选出 top1000 中包含这些名字的数据 print(filtered.groupby(‘name’)[‘births’].sum()) # 按名字统计出生人数</p>
<p>table = filtered.pivot_table(‘births’, index=‘year’, # 以 ‘year’ 为索引 columns=‘sex’, aggfunc=sum) # 以 ‘sex’ 为列，计算 ‘births’ 的总和 table = table.div(table.sum(axis=“columns”), axis=“index”) # 计算每个年份中，每个性别的比例 print(table.tail()) # 显示最后几行 table.plot(style={‘M’: ‘k-’, ‘F’: ‘k–’}) # 绘制趋势图 plt.show() #显示绘图</p>
<pre><code>
-   **目标：** 找到改变了性别偏好的名字。
-   **`all_names = ...`**:  `top1000` 中所有*唯一*的名字。
-   **`lesley_like = ...`**: 包含 "Lesl" 的名字。
-   **`filtered = ...`**: `top1000` 中包含这些名字的行。
-   **`filtered.groupby('name')['births'].sum()`**:  每个名字的总出生人数。
-   **`table = filtered.pivot_table(...)`**: 每年、每性别的出生人数。
-   **`table = table.div(..., axis="index")`**:  每年每性别的*比例*（标准化）。
-   **`table.plot(...)`**:  男性/女性比例的趋势。

!['随着时间的推移，类似 Lesley 的名字的男性/女性比例'](lesleylike_names.png)

## 13.4 USDA 食品数据库 🍎

-   **数据集：** USDA 食品营养数据库。
-   **数据格式：** JSON。
-   **示例记录：**

```json
{
  "id": 21441,
  "description": "KENTUCKY FRIED CHICKEN, Fried Chicken, EXTRA CRISPY, Wing, meat and skin with breading",
  "tags": ["KFC"],
  "manufacturer": "Kentucky Fried Chicken",
  "group": "Fast Foods",
  "portions": [
    {
      "amount": 1,
      "unit": "wing, with skin",
      "grams": 68.0
    }
  ],
  "nutrients": [
    {
      "value": 20.8,
      "units": "g",
      "description": "Protein",
      "group": "Composition"
    }
  ]
}</code></pre>
<ul>
<li><strong>目标：</strong> 分析营养信息。</li>
</ul>
<p><img src="usda_food_intro.png" class="img-fluid"></p>
</section>
<section id="加载和探索-usda-数据" class="level2">
<h2 class="anchored" data-anchor-id="加载和探索-usda-数据">加载和探索 USDA 数据</h2>
<p>``````goylqeae import json # 导入 json 库 import pandas as pd</p>
<p>db = json.load(open(‘datasets/usda_food/database.json’)) # 加载 JSON 数据 print(len(db)) # 显示记录数量 print(db[0].keys()) # 显示第一条记录的键 print(db[0][‘nutrients’][0]) # 显示第一条记录的第一个营养素</p>
<p>nutrients = pd.DataFrame(db[0][‘nutrients’]) # 创建第一个食物的营养素 DataFrame print(nutrients.head(7)) # 显示前 7 行</p>
<pre><code>
-   **`import json`**: 导入 `json` 库。
-   **`db = json.load(...)`**:  将 JSON 加载到 ```{python} 对象（`db` - 字典列表）中。
-   **`len(db)`**:  食物记录的数量。
-   **`db[0].keys()`**: 第一条记录中的键。
-   **`db[0]['nutrients'][0]`**:  第一个食物的第一个营养素。
-   **`nutrients = pd.DataFrame(...)`**: *第一个*食物的营养素的 DataFrame。

## 提取食物信息

``````{python}
info_keys = ['description', 'group', 'id', 'manufacturer']  # 要提取的键
info = pd.DataFrame(db, columns=info_keys)  # 创建包含食物信息的 DataFrame
print(info.head())  # 显示前几行
print(info.info())  # 显示 DataFrame 的信息
print(pd.value_counts(info['group'])[:10])  # 统计并显示出现次数最多的前 10 个食物组</code></pre>
<ul>
<li><strong>目标：</strong> 包含基本食物信息的 DataFrame (<code>info</code>)。</li>
<li><strong><code>info_keys = [...]</code></strong>: 要提取的键。</li>
<li><strong><code>info = pd.DataFrame(db, columns=info_keys)</code></strong>: 创建 DataFrame。</li>
<li><strong><code>info.head()</code></strong>: 前几行。</li>
<li><strong><code>info.info()</code></strong>: 摘要。</li>
<li><strong><code>pd.value_counts(info['group'])[:10]</code></strong>: 前 10 个食物组。</li>
</ul>
</section>
<section id="处理营养数据所有食物" class="level2">
<h2 class="anchored" data-anchor-id="处理营养数据所有食物">处理营养数据（所有食物）</h2>
<p>``````goylqeae nutrients = [] # 用于存储所有食物的营养素</p>
<p>for rec in db: # 遍历食物记录 fnuts = pd.DataFrame(rec[‘nutrients’]) # 创建当前食物的营养素 DataFrame fnuts[‘id’] = rec[‘id’] # 添加食物 ID nutrients.append(fnuts) # 将当前食物的营养素 DataFrame 添加到列表</p>
<p>nutrients = pd.concat(nutrients, ignore_index=True) # 合并所有营养素 DataFrame print(nutrients) # 显示合并后的 DataFrame</p>
<pre><code>
-   **目标**：包含*所有*营养信息的单个 DataFrame (`nutrients`)。
-   **循环：**
    -   `for rec in db:`: 遍历食物记录。
    -   `fnuts = pd.DataFrame(rec['nutrients'])`: 当前食物营养素的 DataFrame。
    -   `fnuts['id'] = rec['id']`: 添加食物 ID（用于链接）。
    -   `nutrients.append(fnuts)`: 追加到列表。
-   **`nutrients = pd.concat(nutrients, ignore_index=True)`**:  合并所有营养素 DataFrame。

## 处理重复项和重命名

``````{python}
nutrients.duplicated().sum()  # 检查重复的行数
nutrients = nutrients.drop_duplicates()  # 删除重复的行

col_mapping = {'description' : 'food',  # 列名映射字典
               'group'       : 'fgroup'}
info = info.rename(columns=col_mapping, copy=False)  # 重命名 info DataFrame 的列
print(info.info())  # 显示重命名后的 info DataFrame 的信息

col_mapping = {'description' : 'nutrient',  # 列名映射字典
               'group' : 'nutgroup'}
nutrients = nutrients.rename(columns=col_mapping, copy=False)  # 重命名 nutrients DataFrame 的列
print(nutrients)  # 显示重命名后的 nutrients DataFrame</code></pre>
<ul>
<li><strong>重复项检查和删除</strong>：
<ul>
<li>某些营养素行是重复的。请在继续之前删除。</li>
<li><code>nutrients.duplicated().sum()</code>: 统计重复的行数。</li>
<li><code>nutrients = nutrients.drop_duplicates()</code>: 删除重复行。</li>
</ul></li>
<li><strong>重命名列：</strong>
<ul>
<li><code>col_mapping = ...</code>: 将旧名称映射到新名称（更清晰）。</li>
<li><code>info = info.rename(..., copy=False)</code>: 重命名 <code>info</code> 列（原地）。</li>
<li><code>nutrients = nutrients.rename(...)</code>: 重命名 <code>nutrients</code> 列。</li>
</ul></li>
</ul>
</section>
<section id="合并食物和营养数据" class="level2">
<h2 class="anchored" data-anchor-id="合并食物和营养数据">合并食物和营养数据</h2>
<p>```<code>goylqeae ndata = pd.merge(nutrients, info, on='id')  # 基于 'id' 列合并 nutrients 和 info DataFrame print(ndata.info())  # 显示合并后的 DataFrame 的信息 print(ndata.iloc[30000])  # 显示第 30001 行数据</code></p>
<ul>
<li><strong><code>ndata = pd.merge(nutrients, info, on='id')</code></strong>: 基于 ‘id’ 合并。包含所有信息的单个 DataFrame。</li>
<li><strong><code>ndata.info()</code></strong>: 摘要。</li>
<li><strong><code>ndata.iloc[30000]</code></strong>: 示例行。</li>
</ul>
</section>
<section id="绘制中位数营养值" class="level2">
<h2 class="anchored" data-anchor-id="绘制中位数营养值">绘制中位数营养值</h2>
<p>```<code>goylqeae result = ndata.groupby(['nutrient', 'fgroup'])['value'].quantile(0.5)  # 按 'nutrient' 和 'fgroup' 分组，计算 'value' 的中位数 result['Zinc, Zn'].sort_values().plot(kind='barh')  # 绘制锌的中位数，按值排序，水平条形图 plt.show() # 显示绘图</code></p>
<ul>
<li><strong>目标：</strong> 可视化每个食物组的中位数营养值。</li>
<li><strong><code>result = ndata.groupby(['nutrient', 'fgroup'])['value'].quantile(0.5)</code></strong>:
<ul>
<li>按营养素和食物组分组。</li>
<li>计算 ‘value’ 的中位数（0.5 分位数）。</li>
</ul></li>
<li><strong><code>result['Zinc, Zn']...plot(kind='barh')</code></strong>:
<ul>
<li>选择锌。</li>
<li>对值进行排序。</li>
<li>水平条形图。</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="zinc_values_foodgroup.png" class="img-fluid figure-img"></p>
<figcaption>‘按食物组划分的锌中位数值’</figcaption>
</figure>
</div>
</section>
<section id="查找具有最大营养值的食物" class="level2">
<h2 class="anchored" data-anchor-id="查找具有最大营养值的食物">查找具有最大营养值的食物</h2>
<p>``````goylqeae by_nutrient = ndata.groupby([‘nutgroup’, ‘nutrient’]) # 按 ‘nutgroup’ 和 ‘nutrient’ 分组</p>
<p>def get_maximum(x): return x.loc[x.value.idxmax()] # 获取每个分组中 ‘value’ 最大的行</p>
<p>max_foods = by_nutrient.apply(get_maximum)[[‘value’, ‘food’]] # 应用函数，并选择 ‘value’ 和 ‘food’ 列 max_foods[‘food’] = max_foods[‘food’].str[:50] # 截断 ‘food’ 列的长度 print(max_foods.loc[‘Amino Acids’][‘food’]) # 显示氨基酸组中，各种营养素含量最高的食物</p>
<pre><code>
-   **目标：** 每种营养素*含量最高*的食物。
-   **`by_nutrient = ndata.groupby(['nutgroup', 'nutrient'])`**: 按营养素组和名称分组。
-   **`get_maximum(x)` 函数：**
    -   接收一个分组。
    -   `x.value.idxmax()`:  'value' 最大的行的*索引*。
    -   `x.loc[...]`:  选择该行。
-   **`max_foods = ...`**: 应用 `get_maximum`，选择 'value' 和 'food'。
-   **`max_foods['food'] = ...str[:50]`**: 缩短食物名称。

## 13.5 2012 年联邦选举委员会数据库 🗳️

-   **数据集：** 2012 年美国 FEC 竞选捐款数据。
-   **内容：**
    -   捐款人姓名。
    -   职业/雇主。
    -   地址。
    -   捐款金额。
-   **数据格式：** CSV。
-   **文件：**  `P00000001-ALL.csv`。
-   **目标：** 分析捐款模式。

``````{python}
import pandas as pd
fec = pd.read_csv('datasets/fec/P00000001-ALL.csv', low_memory=False)  # 读取 CSV 文件
print(fec.info())  # 显示 DataFrame 的信息
print(fec.iloc[123456])  # 显示第 123457 行数据</code></pre>
<ul>
<li><strong><code>fec = pd.read_csv(...)</code></strong>: 加载 CSV。</li>
<li><strong><code>low_memory=False</code></strong>: <em>重要</em>。大文件；使用 <code>False</code> 以进行准确的类型推断。</li>
<li><strong><code>fec.info()</code></strong>: 摘要。</li>
<li><strong><code>fec.iloc[123456]</code></strong>: 示例记录。</li>
</ul>
<p><img src="fec_intro.png" class="img-fluid"></p>
</section>
<section id="添加政党归属" class="level2">
<h2 class="anchored" data-anchor-id="添加政党归属">添加政党归属</h2>
<p>``````goylqeae unique_cands = fec[‘cand_nm’].unique() # 获取唯一的候选人姓名 print(unique_cands) # 显示唯一的候选人姓名</p>
<p>parties = {‘Bachmann, Michelle’: ‘Republican’, # 候选人姓名与政党的映射字典 ‘Cain, Herman’: ‘Republican’, ‘Gingrich, Newt’: ‘Republican’, ‘Huntsman, Jon’: ‘Republican’, ‘Johnson, Gary Earl’: ‘Republican’, ‘McCotter, Thaddeus G’: ‘Republican’, ‘Obama, Barack’: ‘Democrat’, ‘Paul, Ron’: ‘Republican’, ‘Pawlenty, Timothy’: ‘Republican’, ‘Perry, Rick’: ‘Republican’, “Roemer, Charles E. ‘Buddy’ III”: ‘Republican’, ‘Romney, Mitt’: ‘Republican’, ‘Santorum, Rick’: ‘Republican’}</p>
<p>print(fec[‘cand_nm’][123456:123461]) # 显示一部分候选人姓名 print(fec[‘cand_nm’][123456:123461].map(parties)) # 将这些候选人姓名映射到政党</p>
<p>fec[‘party’] = fec[‘cand_nm’].map(parties) # 基于映射字典，创建 ‘party’ 列 print(fec[‘party’].value_counts()) # 统计每个政党的捐款数量</p>
<pre><code>
-   **`unique_cands = fec['cand_nm'].unique()`**: 唯一候选人姓名。
-   **`parties = {...}`**:  字典：候选人姓名 -&gt; 政党。
-   **`fec['cand_nm'][...].map(parties)`**:  展示 `map` 的工作原理。
-   **`fec['party'] = fec['cand_nm'].map(parties)`**: 创建 'party' 列。
-   **`fec['party'].value_counts()`**:  每个政党的计数。

## 过滤捐款（仅限正金额）

``````{python}
print((fec['contb_receipt_amt'] &gt; 0).value_counts())  # 统计捐款金额大于 0 和小于等于 0 的数量

fec = fec[fec['contb_receipt_amt'] &gt; 0]  # 仅保留捐款金额大于 0 的数据</code></pre>
<ul>
<li><strong>问题</strong>：包括捐款（正）和退款（负）。</li>
<li><strong><code>(... &gt; 0).value_counts()</code></strong>: 检查正/负计数。</li>
<li><strong><code>fec = fec[... &gt; 0]</code></strong>: 过滤以仅保留正捐款。</li>
</ul>
</section>
<section id="按候选人过滤奥巴马和罗姆尼" class="level2">
<h2 class="anchored" data-anchor-id="按候选人过滤奥巴马和罗姆尼">按候选人过滤（奥巴马和罗姆尼）</h2>
<p>```<code>goylqeae fec_mrbo = fec[fec['cand_nm'].isin(['Obama, Barack', 'Romney, Mitt'])]  # 仅保留奥巴马和罗姆尼的捐款数据</code></p>
<ul>
<li><strong>目标：</strong> 关注两位主要候选人。</li>
<li><strong><code>fec_mrbo = fec[fec['cand_nm'].isin([...])]</code></strong>: 过滤奥巴马/罗姆尼。</li>
</ul>
</section>
<section id="按职业和雇主划分的捐款统计" class="level2">
<h2 class="anchored" data-anchor-id="按职业和雇主划分的捐款统计">按职业和雇主划分的捐款统计</h2>
<p>``````goylqeae print(fec[‘contbr_occupation’].value_counts()[:10]) # 统计并显示出现次数最多的前 10 个职业</p>
<p>occ_mapping = { # 职业映射字典，将相似的职业名称统一 ‘INFORMATION REQUESTED PER BEST EFFORTS’ : ‘NOT PROVIDED’, ‘INFORMATION REQUESTED’ : ‘NOT PROVIDED’, ‘INFORMATION REQUESTED (BEST EFFORTS)’ : ‘NOT PROVIDED’, ‘C.E.O.’: ‘CEO’ }</p>
<p>def get_occ(x): # 如果没有提供映射，则返回 x return occ_mapping.get(x, x) # 获取映射，如果不存在则返回原值</p>
<p>fec[‘contbr_occupation’] = fec[‘contbr_occupation’].map(get_occ) # 应用职业映射</p>
<pre><code>
-   **`fec['contbr_occupation'].value_counts()[:10]`**: 前 10 个职业。
-   **问题：** 相似职业的变体 ("INFORMATION REQUESTED")。
-   **`occ_mapping = {...}`**: 将变体映射到标准形式。
-   **`get_occ(x)` 函数：**
    -   使用 `occ_mapping.get(x, x)`。如果 `x` 在字典中，则返回映射的值；否则，返回 `x`。
-   **`fec['contbr_occupation'] = ...map(get_occ)`**: 标准化职业。

## 按职业和雇主划分的捐款统计（续）- 雇主 + 数据透视表

``````{python}
emp_mapping = {  # 雇主映射字典，将相似的雇主名称统一
    'INFORMATION REQUESTED PER BEST EFFORTS' : 'NOT PROVIDED',
    'INFORMATION REQUESTED' : 'NOT PROVIDED',
    'SELF' : 'SELF-EMPLOYED',
    'SELF EMPLOYED' : 'SELF-EMPLOYED',
}

def get_emp(x):
    # 如果没有提供映射，则返回 x
    return emp_mapping.get(x, x)  # 获取映射，如果不存在则返回原值

fec['contbr_employer'] = fec['contbr_employer'].map(get_emp)  # 应用雇主映射

by_occupation = fec.pivot_table('contb_receipt_amt',  # 创建数据透视表
                                index='contbr_occupation',  # 以 'contbr_occupation' 为索引
                                columns='party', aggfunc='sum')  # 以 'party' 为列，计算 'contb_receipt_amt' 的总和

over_2mm = by_occupation[by_occupation.sum(axis="columns") &gt; 2000000]  # 筛选出总捐款金额大于 200 万的职业
print(over_2mm)  # 显示筛选结果</code></pre>
<ul>
<li><p>雇主：与职业相同的过程。</p></li>
<li><p><strong><code>by_occupation = fec.pivot_table(...)</code></strong>: 按职业/政党的捐款。</p>
<ul>
<li><code>'contb_receipt_amt'</code>: 要聚合的值。</li>
<li><code>index='contbr_occupation'</code>: 职业是行索引。</li>
<li><code>columns='party'</code>: 政党成为列。</li>
<li><code>aggfunc='sum'</code>: 总捐款。</li>
</ul></li>
<li><p><strong><code>over_2mm = ...</code></strong>: 总捐款 &gt; 200 万美元的职业。</p></li>
</ul>
<p>```<code>goylqeae over_2mm.plot(kind='barh')  # 绘制水平条形图 plt.show()  #显示绘图</code></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="donations_by_occupation.png" class="img-fluid figure-img"></p>
<figcaption>‘按热门职业划分的各政党总捐款额’</figcaption>
</figure>
</div>
</section>
<section id="热门捐款人职业和雇主针对奥巴马和罗姆尼" class="level2">
<h2 class="anchored" data-anchor-id="热门捐款人职业和雇主针对奥巴马和罗姆尼">热门捐款人职业和雇主（针对奥巴马和罗姆尼）</h2>
<p>``````goylqeae def get_top_amounts(group, key, n=5): totals = group.groupby(key)[‘contb_receipt_amt’].sum() # 按 key 分组，计算 ‘contb_receipt_amt’ 的总和 return totals.nlargest(n) # 返回总和最大的前 n 个</p>
<p>grouped = fec_mrbo.groupby(‘cand_nm’) # 按候选人姓名分组 print(grouped.apply(get_top_amounts, ‘contbr_occupation’, n=7)) # 获取每个候选人捐款金额最多的前 7 个职业 print(grouped.apply(get_top_amounts, ‘contbr_employer’, n=10)) # 获取每个候选人捐款金额最多的前 10 个雇主</p>
<pre><code>
-   **`get_top_amounts(group, key, n=5)` 函数：**
    -   `group`: DataFrame 分组（例如，一位候选人的捐款）。
    -   `key`: 要分组的列（职业/雇主）。
    -   `n`: 热门项目的数量。
    -   计算每个职业/雇主的总捐款，返回前 `n` 个。
-   **`grouped = fec_mrbo.groupby('cand_nm')`**: 按候选人分组。
-   **`grouped.apply(...)`**:  查找*每个候选人*的热门职业/雇主。

## 对捐款金额进行分桶

``````{python}
import numpy as np

bins = np.array([0, 1, 10, 100, 1000, 10000, 100_000, 1_000_000, 10_000_000])  # 定义分桶边界
labels = pd.cut(fec_mrbo['contb_receipt_amt'], bins)  # 将捐款金额分配到各个桶中
print(labels)  # 显示分桶结果

grouped = fec_mrbo.groupby(['cand_nm', labels])  # 按候选人姓名和分桶标签分组
print(grouped.size().unstack(level=0))  # 统计每个候选人在每个桶中的捐款数量

bucket_sums = grouped['contb_receipt_amt'].sum().unstack(level=0)  # 计算每个候选人在每个桶中的总捐款金额
normed_sums = bucket_sums.div(bucket_sums.sum(axis="columns"),  # 计算每个桶中，每个候选人捐款金额的比例
                              axis="index")
print(normed_sums)  # 显示比例
normed_sums[:-2].plot(kind='barh')  # 绘制水平条形图，不包括最大的两个桶
plt.show()  #显示绘图</code></pre>
<ul>
<li><strong>目标：</strong> 按捐款规模分档分析。</li>
<li><strong><code>bins = np.array([...])</code></strong>: 定义桶边界。</li>
<li><strong><code>labels = pd.cut(..., bins)</code></strong>: 将每个捐款分配到一个桶。</li>
<li><strong><code>grouped = ...groupby(['cand_nm', labels])</code></strong>: 按候选人<em>和</em>桶分组。</li>
<li><strong><code>grouped.size().unstack(...)</code></strong>: 每个桶/候选人的计数。</li>
<li><strong><code>bucket_sums = ...</code></strong>: 每个桶/候选人的<em>总</em>金额。</li>
<li><strong><code>normed_sums = ...</code></strong>: 每个桶/候选人的<em>百分比</em>（标准化）。</li>
<li><strong><code>normed_sums[:-2].plot(kind='barh')</code></strong>: 条形图（不包括最大的桶）。</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="donation_size.png" class="img-fluid figure-img"></p>
<figcaption>‘候选人收到的各种规模捐款占总捐款的百分比’</figcaption>
</figure>
</div>
</section>
<section id="按州划分的捐款统计" class="level2">
<h2 class="anchored" data-anchor-id="按州划分的捐款统计">按州划分的捐款统计</h2>
<p>``````goylqeae grouped = fec_mrbo.groupby([‘cand_nm’, ‘contbr_st’]) # 按候选人姓名和州分组 totals = grouped[‘contb_receipt_amt’].sum().unstack(level=0).fillna(0) # 计算每个候选人在每个州的总捐款金额，并填充缺失值 totals = totals[totals.sum(axis=“columns”) &gt; 100000] # 筛选出总捐款金额大于 10 万的州 print(totals.head(10)) # 显示前 10 行</p>
<p>percent = totals.div(totals.sum(axis=“columns”), axis=“index”) # 计算每个州中，每个候选人捐款金额的比例 print(percent.head(10)) # 显示前 10 行 ```</p>
<ul>
<li><strong>目标：</strong> 按捐款人所在州进行分析。</li>
<li><strong><code>grouped = ...groupby(['cand_nm', 'contbr_st'])</code></strong>: 按候选人/州分组。</li>
<li><strong><code>totals = ...sum().unstack(...).fillna(0)</code></strong>: 每个州/候选人的总数。<code>unstack</code> 将候选人作为列，<code>fillna(0)</code> 处理缺失数据。</li>
<li><strong><code>totals = totals[...]</code></strong>: 过滤总数 &gt; 100,000 美元的州。</li>
<li><strong><code>percent = totals.div(...)</code></strong>: 每个州/候选人的<em>百分比</em>。</li>
</ul>
</section>
<section id="总结" class="level2">
<h2 class="anchored" data-anchor-id="总结">总结</h2>
<ul>
<li>演示了使用 ```{python} 进行真实世界数据分析。</li>
<li>数据集：Bitly/USA.gov、MovieLens、婴儿姓名、USDA 食品、FEC。</li>
<li><strong>关键技术：</strong>
<ul>
<li>加载（文本、JSON、CSV）。</li>
<li>清理/转换（缺失数据、字符串、类型）。</li>
<li>聚合/分组 (<code>groupby</code>、<code>pivot_table</code>、<code>apply</code>)。</li>
<li>合并/重塑 (<code>merge</code>、<code>concat</code>、<code>unstack</code>、<code>stack</code>、<code>explode</code>)。</li>
<li>可视化 (matplotlib, seaborn)。</li>
<li>时间序列。</li>
</ul></li>
<li>迭代探索：从原始数据开始，清理，并构建分析。</li>
</ul>
</section>
<section id="思考和讨论" class="level2">
<h2 class="anchored" data-anchor-id="思考和讨论">思考和讨论</h2>
<ul>
<li>如何扩展/改进这些分析？其他问题？</li>
<li>局限性和假设？偏差？</li>
<li>将技术应用于其他数据集？</li>
<li>真实世界数据（尤其是关于人的数据）的伦理考虑？</li>
<li>权衡：纯 ``<code>{python}、</code>collections`、pandas。什么时候最好？</li>
<li>可视化选择如何影响见解？</li>
<li>探索官方文档以加深理解。</li>
<li>商科专业：这些技能对职业有何用处？提供竞争优势。</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/qiufei\.github\.io\/web-slide-pandas3ed");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>🔋<a href="https://posit.co"><img src="https://posit.co/wp-content/themes/Posit/assets/images/posit-logo-2024.svg" class="img-fluid" alt="Posit" width="65"></a></p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 邱飞 © 2025
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://beian.miit.gov.cn">
<p>浙ICP备 2024072710号-1</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33021202002511">
<p>浙公网安备 33021202002511号</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:hfutqiufei@163.com">
      <i class="bi bi-envelope-at-fill" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>